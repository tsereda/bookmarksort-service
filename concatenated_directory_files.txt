=== app/__init__.py ===
from flask import Flask
from flask_cors import CORS
from flask_restx import Api

from .api.bookmarks import bookmarks_ns
from .api.topics import topics_ns
from .api.visualizations import visualizations_ns
from .api.search import search_ns
from .services.bookmark_service import BookmarkService
from .services.topic_service import TopicService
from .services.visualization_service import VisualizationService
from .services.embedding_service import EmbeddingService
from .utils.database import BookmarkDatabase

def create_app():
    app = Flask(__name__)
    
    # Configure CORS
    CORS(app, resources={r"/*": {
        "origins": ["chrome-extension://*", "moz-extension://*", "http://localhost:*"],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization", "Access-Control-Allow-Credentials"],
    }}, supports_credentials=True)

    api = Api(app, version='1.0', title='Bookmark Organizer API',
              description='A sophisticated Bookmark Organizer API with topic modeling capabilities')

    # Initialize services
    database = BookmarkDatabase()
    embedding_service = EmbeddingService(database)
    topic_service = TopicService(database, embedding_service)
    bookmark_service = BookmarkService(database, embedding_service, topic_service)
    visualization_service = VisualizationService(topic_service, bookmark_service)

    # Register namespaces
    api.add_namespace(bookmarks_ns)
    api.add_namespace(topics_ns)
    api.add_namespace(visualizations_ns)
    api.add_namespace(search_ns)

    # Inject services into namespaces
    bookmarks_ns.bookmark_service = bookmark_service
    bookmarks_ns.embedding_service = embedding_service
    topics_ns.topic_service = topic_service
    visualizations_ns.visualization_service = visualization_service
    search_ns.bookmark_service = bookmark_service

    @app.after_request
    def after_request(response):
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')
        return response

    return app
=== app/utils/database.py ===
import sqlite3
import numpy as np
from typing import List, Dict, Any

class BookmarkDatabase:
    def __init__(self, db_name: str = "bookmarks.db"):
        self.db_name = db_name
        self.init_db()

    def init_db(self):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute('''CREATE TABLE IF NOT EXISTS bookmarks
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          title TEXT NOT NULL,
                          url TEXT NOT NULL,
                          tags TEXT,
                          embedding BLOB,
                          topic INTEGER)''')
            c.execute('''CREATE TABLE IF NOT EXISTS metadata
                         (key TEXT PRIMARY KEY,
                          value TEXT)''')
            c.execute('''CREATE TABLE IF NOT EXISTS topics
                         (id INTEGER PRIMARY KEY,
                          name TEXT)''')
            conn.commit()

    def add_bookmark(self, bookmark: Dict[str, Any]) -> int:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("""
                INSERT INTO bookmarks (title, url, tags, embedding, topic)
                VALUES (?, ?, ?, ?, ?)
            """, (
                bookmark['title'],
                bookmark['url'],
                ','.join(bookmark.get('tags', [])),
                bookmark.get('embedding', None),
                int(bookmark.get('topic', -1))
            ))
            return c.lastrowid

    def get_bookmarks(self) -> List[Dict[str, Any]]:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("SELECT id, title, url, tags, topic FROM bookmarks")
            bookmarks = []
            for row in c.fetchall():
                bookmark = {
                    'id': row[0],
                    'title': row[1],
                    'url': row[2],
                    'tags': row[3].split(',') if row[3] else [],
                    'topic': row[4]
                }
                bookmarks.append(bookmark)
            return bookmarks

    def get_embeddings(self) -> np.ndarray:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("SELECT embedding FROM bookmarks WHERE embedding IS NOT NULL")
            embeddings = [np.frombuffer(row[0], dtype=np.float32) for row in c.fetchall()]
            return np.array(embeddings)

    def update_bookmark_embedding(self, bookmark_id: int, embedding: np.ndarray):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("UPDATE bookmarks SET embedding = ? WHERE id = ?", (embedding.tobytes(), bookmark_id))
            conn.commit()

    def set_metadata(self, key: str, value: str):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)", (key, value))
            conn.commit()

    def get_metadata(self, key: str) -> str:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("SELECT value FROM metadata WHERE key = ?", (key,))
            result = c.fetchone()
            return result[0] if result else None
        
    def update_bookmark_topic(self, bookmark_id: int, topic: int):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("UPDATE bookmarks SET topic = ? WHERE id = ?", (topic, bookmark_id))
            conn.commit()

    def get_untagged_bookmarks(self, limit: int = None) -> List[Dict[str, Any]]:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            query = """
                SELECT id, title, url FROM bookmarks
                WHERE tags IS NULL OR tags = ''
            """
            if limit:
                query += f" LIMIT {limit}"
            c.execute(query)
            return [{'id': row[0], 'title': row[1], 'url': row[2]} for row in c.fetchall()]

    def update_bookmark_tags(self, bookmark_id: int, tags: List[str]):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("""
                UPDATE bookmarks
                SET tags = ?
                WHERE id = ?
            """, (','.join(tags), bookmark_id))
            conn.commit()

    def update_topic_name(self, topic_id: int, name: str):
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("""
                INSERT OR REPLACE INTO topics (id, name)
                VALUES (?, ?)
            """, (topic_id, name))
            conn.commit()

    def get_topic_names(self) -> Dict[int, str]:
        with sqlite3.connect(self.db_name) as conn:
            c = conn.cursor()
            c.execute("SELECT id, name FROM topics")
            return {row[0]: row[1] for row in c.fetchall()}
=== app/models/__init__.py ===
from .api_models import create_models

__all__ = ['create_models']
=== app/models/bookmark.py ===
class Bookmark:
    def __init__(self, id, title, url, tags=None, topic=None):
        self.id = id
        self.title = title
        self.url = url
        self.tags = tags or []
        self.topic = topic
=== app/models/api_models.py ===
from flask_restx import fields, Model

def create_models(api):
    bookmark_model = api.model('Bookmark', {
        'title': fields.String(required=True, description='The bookmark title'),
        'url': fields.String(required=True, description='The bookmark URL'),
        'tags': fields.List(fields.String, description='List of tags'),
        'topic': fields.Integer(description='Topic ID', allow_null=True)
    })

    bookmark_response = api.inherit('BookmarkResponse', bookmark_model, {
        'id': fields.Integer(description='The bookmark ID')
    })

    topic_word_model = api.model('TopicWord', {
        'word': fields.String(description='Word in the topic'),
        'score': fields.Float(description='Score of the word in the topic')
    })

    topic_model = api.model('Topic', {
        'id': fields.Integer(description='Topic ID'),
        'name': fields.String(description='Topic name'),
        'count': fields.Integer(description='Number of documents in the topic'),
        'representation': fields.List(fields.Nested(topic_word_model), description='Top words and their scores for this topic')
    })

    scatter_plot_point = api.model('ScatterPlotPoint', {
        'id': fields.Integer(description='Bookmark ID'),
        'x': fields.Float(description='X coordinate'),
        'y': fields.Float(description='Y coordinate'),
        'topic': fields.Integer(description='Topic ID'),
        'title': fields.String(description='Bookmark title'),
        'url': fields.String(description='Bookmark URL'),
        'tags': fields.List(fields.String, description='List of tags'),
        'color': fields.String(description='Color associated with the topic')
    })

    embedding_request = api.model('EmbeddingRequest', {
        'embedding_model': fields.String(description='Name of the embedding model to use',
                                         example='all-MiniLM-L6-v2')
    })

    return bookmark_model, bookmark_response, topic_model, scatter_plot_point, embedding_request
=== app/api/visualizations.py ===
from flask import jsonify
from flask_restx import Namespace, Resource
from ..models.api_models import create_models

visualizations_ns = Namespace('visualizations', description='Visualization operations')

_, _, _, scatter_plot_point, _ = create_models(visualizations_ns)

@visualizations_ns.route('/scatter_plot')
class ScatterPlotVisualization(Resource):
    @visualizations_ns.doc('get_scatter_plot_data',
        description='Get data for scatter plot visualization of bookmarks and their topics.',
        responses={
            200: 'Success. Returns scatter plot data.',
            400: 'Bad request. Topics may not have been created.',
            500: 'Server error. An error occurred while fetching scatter plot data.'
        })
    @visualizations_ns.marshal_list_with(scatter_plot_point)
    def get(self):
        """Get data for scatter plot visualization"""
        try:
            scatter_data = visualizations_ns.visualization_service.get_scatter_plot_data()
            return scatter_data, 200
        except ValueError as e:
            visualizations_ns.logger.error(f"Error fetching scatter plot data: {str(e)}")
            return {'message': str(e)}, 400
        except Exception as e:
            visualizations_ns.logger.error(f"Error fetching scatter plot data: {str(e)}")
            return {'message': f'An error occurred while fetching scatter plot data: {str(e)}'}, 500

@visualizations_ns.route('/sunburst')
class SunburstVisualization(Resource):
    @visualizations_ns.doc('get_sunburst_data',
        description='Get data for sunburst visualization of topics and their hierarchies.',
        responses={
            200: 'Success. Returns sunburst data.',
            400: 'Bad request. Topics may not have been created.',
            500: 'Server error. An error occurred while fetching sunburst data.'
        })
    def get(self):
        """Get data for sunburst visualization"""
        try:
            sunburst_data = visualizations_ns.visualization_service.get_sunburst_data()
            if "error" in sunburst_data:
                return {'message': sunburst_data["error"]}, 400
            return jsonify(sunburst_data)
        except Exception as e:
            return {'message': 'An error occurred while fetching sunburst data', 'error': str(e)}, 500
=== app/api/topics.py ===
from flask import jsonify
from flask_restx import Namespace, Resource
from ..models.api_models import create_models
import asyncio

topics_ns = Namespace('topics', description='Topic operations')

_, _, topic_model, _, _ = create_models(topics_ns)

@topics_ns.route('/')
class Topics(Resource):
    @topics_ns.doc('create_topics',
        description='Create topics for all bookmarks using the generated embeddings.',
        responses={
            200: 'Topics created successfully.',
            400: 'Bad request. Embeddings may not have been generated.',
            500: 'Server error. An error occurred while creating topics.'
        })
    def post(self):
        """Create topics for all bookmarks"""
        try:
            result = topics_ns.topic_service.create_topics()
            if "error" in result:
                return result, 400
            return result, 200
        except Exception as e:
            return {'message': 'An error occurred while creating topics', 'error': str(e)}, 500

@topics_ns.route('/<int:topic_id>')
class Topic(Resource):
    @topics_ns.doc('get_topic',
        description='Get the representation of a specific topic.',
        params={'topic_id': 'The ID of the topic to retrieve'},
        responses={
            200: 'Success. Returns the topic representation.',
            404: 'Topic not found.',
            500: 'Server error. An error occurred while fetching the topic.'
        })
    @topics_ns.marshal_with(topic_model)
    def get(self, topic_id):
        """Get representation of a specific topic"""
        try:
            topic = topics_ns.topic_service.get_topic_representation(topic_id)
            if topic:
                return topic, 200
            return {'message': 'Topic not found'}, 404
        except ValueError as e:
            topics_ns.logger.error(f"Error fetching topic: {str(e)}")
            return {'message': str(e)}, 400
        except Exception as e:
            topics_ns.logger.error(f"Error fetching topic: {str(e)}")
            return {'message': f'An error occurred while fetching the topic: {str(e)}'}, 500

@topics_ns.route('/tree')
class TopicTree(Resource):
    @topics_ns.doc('get_topic_tree',
        description='Get the hierarchical topic tree structure.',
        responses={
            200: 'Success. Returns the topic tree structure.',
            400: 'Bad request. Topics may not have been created.',
            500: 'Server error. An error occurred while fetching the topic tree.'
        })
    def get(self):
        """Get the topic tree structure"""
        try:
            tree = topics_ns.topic_service.get_topic_tree()
            return jsonify({"tree": tree})
        except ValueError as e:
            return {'message': str(e)}, 400
        except Exception as e:
            return {'message': 'An error occurred while fetching the topic tree', 'error': str(e)}, 500

@topics_ns.route('/tree_json')
class TopicTreeJSON(Resource):
    @topics_ns.doc('get_topic_tree_json',
        description='Get the hierarchical topic tree structure as JSON.',
        responses={
            200: 'Success. Returns the topic tree structure as JSON.',
            400: 'Bad request. Topics may not have been created.',
            500: 'Server error. An error occurred while fetching the topic tree JSON.'
        })
    def get(self):
        """Get the topic tree structure as JSON"""
        try:
            tree_json = topics_ns.topic_service.get_tree_json()
            return jsonify(tree_json)
        except ValueError as e:
            return {'message': str(e)}, 400
        except Exception as e:
            return {'message': 'An error occurred while fetching the topic tree JSON', 'error': str(e)}, 500

@topics_ns.route('/regenerate-names')
class RegenerateTopicNames(Resource):
    @topics_ns.doc('regenerate_topic_names',
        description='Regenerate names for all topics based on their hierarchical structure.',
        responses={
            200: 'Success. Returns the updated topic tree.',
            500: 'Server error. An error occurred while regenerating topic names.'
        })
    def post(self):
        """Regenerate names for all topics"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            result = loop.run_until_complete(topics_ns.topic_service.regenerate_topic_names())
            loop.close()
            return result, 200
        except Exception as e:
            return {'message': 'An error occurred while regenerating topic names', 'error': str(e)}, 500
=== app/api/search.py ===
# app/api/search.py

from flask import request, jsonify
from flask_restx import Namespace, Resource

search_ns = Namespace('search', description='Search operations')

@search_ns.route('/')
class Search(Resource):
    @search_ns.doc('search_bookmarks',
        description='Search bookmarks based on a query string.',
        params={'q': 'The search query string'},
        responses={
            200: 'Success. Returns search results.',
            500: 'Server error. An error occurred while searching bookmarks.'
        })
    def get(self):
        """Search bookmarks"""
        try:
            query = request.args.get('q', '')
            results = search_ns.bookmark_service.search_bookmarks(query)
            return jsonify(results)
        except Exception as e:
            return {'message': 'An error occurred while searching bookmarks', 'error': str(e)}, 500

# Don't forget to update __init__.py to include this new namespace
=== app/api/bookmarks.py ===
from flask import request, jsonify
from flask_restx import Namespace, Resource
from ..models.api_models import create_models
import asyncio

bookmarks_ns = Namespace('bookmarks', description='Bookmark operations')

bookmark_model, bookmark_response, _, _, embedding_request = create_models(bookmarks_ns)

@bookmarks_ns.route('/')
class BookmarkList(Resource):
    @bookmarks_ns.doc('list_bookmarks',
        description='Retrieve a list of all bookmarks with their associated topics.',
        responses={
            200: 'Success. Returns a list of all bookmarks.',
            500: 'Server error. An error occurred while fetching bookmarks.'
        })
    @bookmarks_ns.marshal_list_with(bookmark_response)
    def get(self):
        """List all bookmarks with their topics"""
        try:
            bookmarks = bookmarks_ns.bookmark_service.get_bookmarks()
            if not bookmarks:
                return [], 200
            return bookmarks, 200
        except Exception as e:
            bookmarks_ns.logger.error(f"Error fetching bookmarks: {str(e)}")
            return {'message': 'An error occurred while fetching bookmarks', 'error': str(e)}, 500

    @bookmarks_ns.doc('add_bookmark',
        description='Add a new bookmark to the database.',
        responses={
            201: 'Bookmark added successfully.',
            500: 'Server error. An error occurred while adding the bookmark.'
        })
    @bookmarks_ns.expect(bookmark_model)
    def post(self):
        """Add a new bookmark"""
        try:
            data = request.json
            result = bookmarks_ns.bookmark_service.add_bookmark(data)
            return result, 201
        except Exception as e:
            return {'message': 'An error occurred while adding the bookmark', 'error': str(e)}, 500

@bookmarks_ns.route('/embeddings')
class BookmarkEmbeddings(Resource):
    @bookmarks_ns.doc('generate_embeddings',
        description='Generate embeddings for all bookmarks.',
        responses={
            200: 'Embeddings generated successfully.',
            400: 'Bad request. Invalid embedding model.',
            500: 'Server error. An error occurred while generating embeddings.'
        })
    @bookmarks_ns.expect(embedding_request)
    def post(self):
        """Generate embeddings for all bookmarks"""
        try:
            data = request.json
            embedding_model = data.get('embedding_model', 'all-MiniLM-L6-v2')
            result = bookmarks_ns.embedding_service.generate_embeddings(embedding_model)
            return result, 200
        except ValueError as e:
            return {'message': str(e)}, 400
        except Exception as e:
            return {'message': 'An error occurred while generating embeddings', 'error': str(e)}, 500

@bookmarks_ns.route('/batch_tag')
class BatchTagBookmarks(Resource):
    @bookmarks_ns.doc('batch_tag_bookmarks',
        description='Tag all untagged bookmarks concurrently with progress updates.',
        responses={
            200: 'Batch tagging process completed successfully.',
            400: 'Bad request. Invalid parameters.',
            500: 'Server error. An error occurred while batch tagging bookmarks.'
        })
    def post(self):
        """Tag all untagged bookmarks concurrently with progress updates"""
        try:
            if request.is_json:
                data = request.get_json()
            elif request.form:
                data = request.form
            else:
                data = {}

            max_concurrent = int(data.get('max_concurrent', 5))
            max_tags = int(data.get('max_tags', 10))
            batch_size = int(data.get('batch_size', 20))

            if max_concurrent <= 0 or max_tags <= 0 or batch_size <= 0:
                return {'message': 'Invalid max_concurrent, max_tags, or batch_size. All must be positive integers.'}, 400

            result = bookmarks_ns.bookmark_service.batch_tag_all_untagged_bookmarks(max_concurrent, max_tags, batch_size)
            return result, 200
        except ValueError as ve:
            return {'message': f'Invalid parameter: {str(ve)}'}, 400
        except Exception as e:
            return {'message': 'An error occurred while batch tagging bookmarks', 'error': str(e)}, 500
=== app/services/topic_service.py ===
from typing import List, Dict, Any
from ..utils.database import BookmarkDatabase
from .embedding_service import EmbeddingService
from bertopic import BERTopic
from umap import UMAP
from hdbscan import HDBSCAN
import numpy as np
from scipy.cluster import hierarchy as sch
from openai import AsyncOpenAI
import asyncio

class TopicService:
    def __init__(self, database: BookmarkDatabase, embedding_service: EmbeddingService):
        self.database = database
        self.embedding_service = embedding_service
        self.topic_model = None
        self.umap_model = UMAP(n_neighbors=15, n_components=2, min_dist=0.0, metric='cosine')
        self.hierarchical_topics = None
        self.client = AsyncOpenAI()

        # HDBSCAN clustering parameters
        self.min_cluster_size = 6
        self.min_samples = None
        self.metric = 'euclidean'
        self.cluster_selection_method = 'eom'
        self.prediction_data = True

    def get_topic_names(self) -> Dict[int, str]:
        stored_names = self.database.get_topic_names()
        if self.topic_model:
            model_names = self.topic_model.get_topic_info()['Name'].to_dict()
            # Merge stored names with model names, preferring stored names
            return {**model_names, **stored_names}
        return stored_names

    async def regenerate_topic_names(self):
        if self.topic_model is None:
            raise ValueError("Topics have not been created. Call create_topics() first.")

        topics = self.topic_model.get_topics()
        new_names = {}

        for topic_id, topic_words in topics.items():
            if topic_id != -1:  # Skip the outlier topic
                words = [word for word, _ in topic_words[:10]]  # Get top 10 words
                new_name = await self._generate_topic_name(words)
                new_names[topic_id] = new_name
                self.database.update_topic_name(topic_id, new_name)

        # Update topic names in the model
        self.topic_model.set_topic_labels(new_names)

        return {"message": f"Regenerated names for {len(new_names)} topics"}

    def get_scatter_plot_data(self):
        bookmarks = self.database.get_bookmarks()
        embeddings = self.get_embeddings()
        reduced_embeddings = self.reduce_embeddings(embeddings)
        topic_names = self.get_topic_names()

        scatter_data = []
        for i, bookmark in enumerate(bookmarks):
            topic_id = bookmark['topic']
            scatter_data.append({
                'id': bookmark['id'],
                'x': float(reduced_embeddings[i, 0]),
                'y': float(reduced_embeddings[i, 1]),
                'topic': topic_id,
                'topicName': topic_names.get(topic_id, f"Topic {topic_id}"),
                'title': bookmark['title'],
                'url': bookmark['url'],
                'tags': bookmark['tags'],
            })
        return scatter_data

    def get_embeddings(self) -> np.ndarray:
        return self.embedding_service.get_embeddings()
    
    def reduce_embeddings(self, embeddings: np.ndarray) -> np.ndarray:
        if self.umap_model is None:
            self.umap_model = UMAP(n_neighbors=15, n_components=2, min_dist=0.0, metric='cosine')
        return self.umap_model.fit_transform(embeddings)

    def create_topics(self):
        bookmarks = self.database.get_bookmarks()
        if not bookmarks:
            return {"message": "No bookmarks found. Add some bookmarks first."}

        embeddings = self.database.get_embeddings()
        if embeddings.size == 0:
            return {"message": "Failed to generate embeddings. Please try again."}

        docs = [f"{b['title']} {b['url']} {' '.join(b['tags'])}" for b in bookmarks]

        try:
            if self.topic_model is None:
                hdbscan_model = HDBSCAN(
                    min_cluster_size=self.min_cluster_size,
                    min_samples=self.min_samples,
                    metric=self.metric,
                    cluster_selection_method=self.cluster_selection_method,
                    prediction_data=self.prediction_data
                )
                self.topic_model = BERTopic(
                    embedding_model=None,
                    hdbscan_model=hdbscan_model,
                    umap_model=self.umap_model
                )
            
            topics, _ = self.topic_model.fit_transform(docs, embeddings=embeddings)
            
            for bookmark, topic in zip(bookmarks, topics):
                self.database.update_bookmark_topic(bookmark['id'], int(topic))
            
            self.hierarchical_topics = self.create_hierarchical_topics(docs)
            
            return {"message": f"Created topics for {len(bookmarks)} bookmarks"}
        except Exception as e:
            return {"message": f"An error occurred while creating topics: {str(e)}"}

    def get_topic_representation(self, topic_id: int):
        if self.topic_model is None:
            raise ValueError("Topics have not been created. Call create_topics() first.")
        
        topic_words = self.topic_model.get_topic(topic_id)
        if not topic_words:
            return None
        
        return {
            'id': topic_id,
            'name': f"Topic {topic_id}",
            'count': len(topic_words),
            'representation': [{'word': word, 'score': score} for word, score in topic_words]
        }

    def create_hierarchical_topics(self, docs):
        try:
            linkage_function = lambda x: sch.linkage(x, 'ward', optimal_ordering=True)
            hierarchical_topics = self.topic_model.hierarchical_topics(docs, linkage_function=linkage_function)
            return hierarchical_topics
        except Exception as e:
            raise ValueError(f"Error creating hierarchical topics: {str(e)}")

    def get_topic_tree(self):
        if self.topic_model is None or self.hierarchical_topics is None:
            raise ValueError("Topics have not been created. Call create_topics() first.")
        
        hier_topics = self.hierarchical_topics
        tree = self.topic_model.get_topic_tree(hier_topics)
        return tree

    def get_tree_json(self):
        if self.hierarchical_topics is None:
            raise ValueError("Hierarchical topics have not been created. Call create_topics() first.")
        
        hier_topics = self.hierarchical_topics
        root = {"name": "Topics", "children": []}

        def build_tree(node, parent_id):
            children = hier_topics[
                (hier_topics['Parent_ID'] == parent_id) &
                (hier_topics['Child_Left_ID'] != hier_topics['Child_Right_ID'])
            ]
            for _, row in children.iterrows():
                left_child = {"name": row['Child_Left_Name'], "children": []}
                right_child = {"name": row['Child_Right_Name'], "children": []}
                node["children"].extend([left_child, right_child])
                build_tree(left_child, row['Child_Left_ID'])
                build_tree(right_child, row['Child_Right_ID'])

        build_tree(root, hier_topics['Parent_ID'].max())
        return root

    def assign_topic_to_bookmark(self, bookmark_data: Dict[str, Any], embedding: np.ndarray) -> int:
        if self.topic_model is None:
            raise ValueError("Topics have not been created. Call create_topics() first.")
        
        doc = f"{bookmark_data['title']} {bookmark_data['url']} {' '.join(bookmark_data.get('tags', []))}"
        topic, _ = self.topic_model.transform([doc], embeddings=[embedding])
        return topic[0]

    async def regenerate_topic_names(self):
        if self.topic_model is None:
            raise ValueError("Topics have not been created. Call create_topics() first.")

        topics = self.topic_model.get_topics()
        new_names = {}

        for topic_id, topic_words in topics.items():
            if topic_id != -1:  # Skip the outlier topic
                words = [word for word, _ in topic_words[:10]]  # Get top 10 words
                new_name = await self._generate_topic_name(words)
                new_names[topic_id] = new_name

        # Update topic names in the model
        self.topic_model.set_topic_labels(new_names)

        # Update topic names in the database (assuming you have a method for this)
        for topic_id, name in new_names.items():
            self.database.update_topic_name(topic_id, name)

        return {"message": f"Named {new_names}"}

    async def _generate_topic_name(self, words: List[str]) -> str:
        prompt = f"Given the following words representing a topic, generate a short, descriptive name for this topic: {', '.join(words)}"
        
        try:
            response = await self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant that generates concise and descriptive topic names."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=20,
                n=1,
                stop=None,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()
        except Exception as e:
            print(f"Error generating topic name: {str(e)}")
            return f"Topic {' '.join(words[:3])}"  # Fallback name
=== app/services/visualization_service.py ===
from .color_service import color_service

class VisualizationService:
    def __init__(self, topic_service, bookmark_service):
        self.topic_service = topic_service
        self.bookmark_service = bookmark_service

    def get_scatter_plot_data(self):
        bookmarks = self.bookmark_service.get_bookmarks()
        embeddings = self.topic_service.get_embeddings()
        reduced_embeddings = self.topic_service.reduce_embeddings(embeddings)
        topic_names = self.topic_service.get_topic_names()

        scatter_data = []
        for i, bookmark in enumerate(bookmarks):
            topic_id = bookmark['topic']
            scatter_data.append({
                'id': bookmark['id'],
                'x': float(reduced_embeddings[i, 0]),
                'y': float(reduced_embeddings[i, 1]),
                'topic': topic_id,
                'topicName': topic_names.get(topic_id, f"Topic {topic_id}"),
                'title': bookmark['title'],
                'url': bookmark['url'],
                'tags': bookmark['tags'],
                'color': color_service.get_color(topic_id)
            })
        return scatter_data

    def get_sunburst_data(self):
        if self.topic_service.hierarchical_topics is None:
            raise ValueError("Hierarchical topics have not been created. Call create_topics() first.")
        
        tree_json = self.topic_service.get_tree_json()
        topic_names = self.topic_service.get_topic_names()
        
        def add_values_and_colors(node, topic_id=0):
            if not node.get("children"):
                node["value"] = 1
                node["color"] = color_service.get_color(topic_id)
            else:
                for i, child in enumerate(node["children"]):
                    child_id = topic_id * 10 + i + 1
                    add_values_and_colors(child, child_id)
                node["value"] = sum(child["value"] for child in node["children"])
            
            if "name" in node:
                node["name"] = topic_names.get(topic_id, node["name"])
        
        add_values_and_colors(tree_json)
        return tree_json
=== app/services/color_service.py ===
import colorsys

class ColorService:
    def __init__(self):
        self.color_map = {}
        self.golden_ratio_conjugate = 0.618033988749895

    def get_color(self, topic_id):
        if topic_id not in self.color_map:
            hue = (topic_id * self.golden_ratio_conjugate) % 1
            r, g, b = [int(x * 255) for x in colorsys.hsv_to_rgb(hue, 0.5, 0.95)]
            self.color_map[topic_id] = f"#{r:02x}{g:02x}{b:02x}"
        return self.color_map[topic_id]

    def get_all_colors(self):
        return self.color_map

color_service = ColorService()
=== app/services/embedding_service.py ===
from typing import List, Dict, Any
from sentence_transformers import SentenceTransformer
import numpy as np
from ..utils.database import BookmarkDatabase

class EmbeddingService:
    def __init__(self, database: BookmarkDatabase):
        self.database = database
        self.embedding_model = None

    def generate_embeddings(self, embedding_model: str = "all-MiniLM-L6-v2"):
        current_model = self.database.get_metadata('embedding_model')
        if current_model == embedding_model:
            return {"message": "Embeddings are up to date"}

        bookmarks = self.database.get_bookmarks()
        if not bookmarks:
            return {"message": "No bookmarks found. Add some bookmarks first."}

        self.embedding_model = SentenceTransformer(embedding_model)
        docs = [f"{b['title']} {b['url']} {' '.join(b['tags'])}" for b in bookmarks]
        embeddings = self.embedding_model.encode(docs)

        for bookmark, embedding in zip(bookmarks, embeddings):
            self.database.update_bookmark_embedding(bookmark['id'], embedding)

        self.database.set_metadata('embedding_model', str(self.embedding_model.get_sentence_embedding_dimension()))
        return {"message": f"Generated embeddings for {len(bookmarks)} bookmarks using {embedding_model}"}

    def get_embeddings(self) -> np.ndarray:
        return self.database.get_embeddings()

    def generate_embedding_for_bookmark(self, bookmark: Dict[str, Any]) -> np.ndarray:
        if self.embedding_model is None:
            model_name = self.database.get_metadata('embedding_model') or "all-MiniLM-L6-v2"
            self.embedding_model = SentenceTransformer(model_name)

        doc = f"{bookmark['title']} {bookmark['url']} {' '.join(bookmark.get('tags', []))}"
        return self.embedding_model.encode([doc])[0]
=== app/services/bookmark_service.py ===
from typing import List, Dict, Any
from ..utils.database import BookmarkDatabase
from .embedding_service import EmbeddingService
from .topic_service import TopicService
import asyncio

class BookmarkService:
    def __init__(self, database: BookmarkDatabase, embedding_service: EmbeddingService, topic_service: TopicService):
        self.database = database
        self.embedding_service = embedding_service
        self.topic_service = topic_service

    def get_bookmarks(self) -> List[Dict[str, Any]]:
        return self.database.get_bookmarks()

    def add_bookmark(self, bookmark_data: Dict[str, Any]) -> Dict[str, Any]:
        bookmark_id = self.database.add_bookmark(bookmark_data)
        
        # Generate embedding for the new bookmark
        embedding = self.embedding_service.generate_embedding_for_bookmark(bookmark_data)
        self.database.update_bookmark_embedding(bookmark_id, embedding)
        
        # Assign topic to the new bookmark if topics have been created
        if self.topic_service.topic_model is not None:
            new_topic = self.topic_service.assign_topic_to_bookmark(bookmark_data, embedding)
            self.database.update_bookmark_topic(bookmark_id, new_topic)
        
        return {"message": "Bookmark added successfully", "id": bookmark_id}

    def get_untagged_bookmarks(self, limit: int = None) -> List[Dict[str, Any]]:
        return self.database.get_untagged_bookmarks(limit)

    def update_bookmark_tags(self, bookmark_id: int, tags: List[str]):
        self.database.update_bookmark_tags(bookmark_id, tags)

    def update_bookmark_topic(self, bookmark_id: int, topic: int):
        self.database.update_bookmark_topic(bookmark_id, topic)

    def search_bookmarks(self, query: str) -> List[Dict[str, Any]]:
        bookmarks = self.database.get_bookmarks()
        return [b for b in bookmarks if query.lower() in b['title'].lower() or query.lower() in b['url'].lower()]

    async def batch_tag_bookmarks(self, bookmarks: List[Dict[str, Any]], max_tags: int = 10) -> Dict[str, Any]:
        if not bookmarks:
            return {"message": "No bookmarks to tag", "tagged_count": 0}

        tags = await self._generate_tags_for_bookmarks(bookmarks, max_tags)
        tagged_count = 0
        for bookmark, bookmark_tags in zip(bookmarks, tags):
            self.update_bookmark_tags(bookmark['id'], bookmark_tags)
            tagged_count += 1

        return {
            "message": f"Tagged {tagged_count} bookmarks",
            "tagged_count": tagged_count
        }

    async def batch_tag_all_untagged_bookmarks(self, max_concurrent: int = 5, max_tags: int = 10, batch_size: int = 20) -> Dict[str, Any]:
        untagged_bookmarks = self.get_untagged_bookmarks()
        
        if not untagged_bookmarks:
            return {"message": "No untagged bookmarks found"}

        total_bookmarks = len(untagged_bookmarks)
        tagged_count = 0
        progress_updates = []

        async def process_batch(batch):
            nonlocal tagged_count
            try:
                result = await self.batch_tag_bookmarks(batch, max_tags)
                tagged_count += result['tagged_count']
                progress = (tagged_count / total_bookmarks) * 100
                return f"Progress: {progress:.2f}% - Tagged {tagged_count} out of {total_bookmarks} bookmarks"
            except Exception as e:
                return f"Error tagging batch: {str(e)}"

        semaphore = asyncio.Semaphore(max_concurrent)
        async def process_with_semaphore(batch):
            async with semaphore:
                return await process_batch(batch)

        batches = [untagged_bookmarks[i:i+batch_size] for i in range(0, total_bookmarks, batch_size)]
        results = await asyncio.gather(*[process_with_semaphore(batch) for batch in batches])
        progress_updates.extend(results)

        return {
            "message": f"Tagged {tagged_count} out of {total_bookmarks} bookmarks",
            "progress_updates": progress_updates
        }

    async def _generate_tags_for_bookmarks(self, bookmarks: List[Dict[str, Any]], max_tags: int) -> List[List[str]]:
        # This method should be implemented to generate tags for bookmarks
        # You might want to use an AI service or some other method to generate tags
        # For now, we'll return empty tag lists
        return [[] for _ in bookmarks]
